# Итоговая проверочная работа.

**Задача**: Написать программу, которая из имеющегося массива строк формирует массив из строк, длина которых
меньше либо равна 3 символа. Первоначальный массив можно ввести с клавиатуры, либо задать на старте
выполнения алгоритма. При решении не рекомендуется пользоваться коллекциями, лучше обойтись
исключительно массивами.

**Решение**

Для решения задачи будем использовать ввод имеющегося массива строк с клавиатуры - таким образом, нам будет удобнее проверить все варианты и исключить ошибки.

Так же, зададим 2 массива (*про то почему именно два - чуть позднее*)

Еще нам понадобится переменная для определения размера входного массива - ее так же введем с клавиатуры

В итоге у нас получились следующие переменные:

1. int arraySize
2. string[] inputArray
3. string[] outputArray
4. string[] resultArray

Перед непосредственным написанием кода нарисуем блок-схему алгоритма решения задачи [тык!](https://github.com/Eugenia4321/final-test-1-quarter/blob/master/Диаграмма.jpg)

У нас есть следующие методы, которые мы не будем рассматривать, так как они используются для ввода и вывода данных:

*void PrintArray(string[] array)*

*string[] FillArray(string[] inputArray)*

*string[] CreateArray(int arraySize)*

А вот метод **решения** рассмотрим подробнее:

>string[] FoundArray(string[] inputArray, string[] outputArray, int itemSize=3)
>
>{
>
>for (int i = 0; i < inputArray.Length; i++)
>
>{
>
>if (inputArray[i].Length <= itemSize)
>
>{
>
>Array.Resize(ref outputArray, outputArray.Length +  1);
>                      
>outputArray[outputArray.Length-1]=inputArray[i];
>
>}
>
> }
>
>return outputArray;
>
>}

Здесь мы используем *Array.Resize()* , который позволяет изменять размер массива, и при каждом нахождении элемента c размером <= 3, мы изменяем размер массива outputArray на +1 и в последнему пустому элементу присваиваем значение найденного элемента.

Но, все-таки, зачем же нам *resultArray[]*?
Несмотря на то, что *FoundArray()* находит и записывает все необходимые элементы в *outputArray[]*, однако после выхода из метода размер *outputArray[]* возвращается к первоначально-заданному, то есть к 0, и все элементы мы теряем.
Если же мы записываем результат в новую переменную *resultArray[]*, то мы можем продолжить работать с результатом! 

## Второй способ

Можно было бы решить задачу иначе - сначала в цикле пройти по входному массиву и посчитать количество элементов, и создавать новый массив зная его размер заранее. Но в этом случае нам пришлось бы использовать цикл 2 раза: при подсчете и при заполнении результирующего массива, что, *возможно*, сказалось бы на быстродействии программы.
